package oracle

import (
	"context"
	"database/sql"
	"net/url"

	"github.com/k3s-io/kine/pkg/logstructured"
	"github.com/k3s-io/kine/pkg/logstructured/sqllog"
	"github.com/k3s-io/kine/pkg/server"
	"github.com/k3s-io/kine/pkg/tls"
	"github.com/k3s-io/kine/pkg/util"
	"github.com/prometheus/client_golang/prometheus"
	_ "github.com/sijms/go-ora/v2"
	"github.com/sirupsen/logrus"
)

const (
	defaultDSN = "oracle://oracle:oracle@localhost:1521/XE"
)

var (
	schema = []string{
		`DECLARE
		tbl_count NUMBER;
		usr_count NUMBER;
		tbl_name VARCHAR2(255) := 'kine';
		usr_name VARCHAR2(255) := 'oracle';
		pwd VARCHAR(255) := 'oracle';
		index_count NUMBER;
		BEGIN
		SELECT COUNT(*) INTO usr_count
		FROM DBA_USERS
		WHERE USERNAME = UPPER(usr_name);
		IF (usr_count = 0) THEN EXECUTE IMMEDIATE (
			'CREATE USER ' || usr_name || ' IDENTIFIED BY ' || pwd || ' DEFAULT TABLESPACE SYSTEM'
		);
		EXECUTE IMMEDIATE (
			'GRANT ALTER SESSION,
								 CREATE ANY TABLE,
								 CREATE CLUSTER,
							  CREATE DATABASE LINK,
							  CREATE MATERIALIZED VIEW,
							 CREATE SYNONYM,
							 CREATE TABLE,
							 CREATE VIEW,
							 CREATE SESSION,
							 UNLIMITED TABLESPACE
						   TO ' || usr_name
		);
		END IF;
		SELECT COUNT(*) INTO tbl_count
		FROM DBA_TABLES
		WHERE OWNER = UPPER(usr_name)
			AND table_name = UPPER(tbl_name);
		IF (tbl_count = 0) THEN EXECUTE IMMEDIATE 'CREATE TABLE ' || usr_name || '.' || tbl_name || ' (
			id NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
			name VARCHAR2(630),
			created NUMBER,
			deleted NUMBER,
			create_revision NUMBER,
			prev_revision NUMBER,
			lease NUMBER,
			value BLOB,
			old_value BLOB
		)';
		END IF;
		SELECT COUNT(*) INTO index_count
		FROM user_indexes
		WHERE index_name = 'KINE_NAME_INDEX';
		IF index_count = 0 THEN EXECUTE IMMEDIATE 'CREATE INDEX KINE_NAME_INDEX ON ' || usr_name || '.' || tbl_name || ' (NAME)';
		END IF;
		SELECT COUNT(*) INTO index_count
		FROM user_indexes
		WHERE index_name = 'KINE_NAME_ID_INDEX';
		IF index_count = 0 THEN EXECUTE IMMEDIATE 'CREATE INDEX KINE_NAME_ID_INDEX ON  ' || usr_name || '.' || tbl_name || '  (NAME, ID)';
		END IF;
		SELECT COUNT(*) INTO index_count
		FROM user_indexes
		WHERE index_name = 'KINE_ID_DELETED_INDEX';
		IF index_count = 0 THEN EXECUTE IMMEDIATE 'CREATE INDEX KINE_ID_DELETED_INDEX ON  ' || usr_name || '.' || tbl_name || ' (ID, DELETED)';
		END IF;
		SELECT COUNT(*) INTO index_count
		FROM user_indexes
		WHERE index_name = 'KINE_PREV_REVISION_INDEX';
		IF index_count = 0 THEN EXECUTE IMMEDIATE 'CREATE INDEX KINE_PREV_REVISION_INDEX ON  ' || usr_name || '.' || tbl_name || ' (PREV_REVISION)';
		END IF;
		SELECT COUNT(*) INTO index_count
		FROM user_indexes
		WHERE index_name = 'KINE_NAME_PREV_REVISION_UINDEX';
		IF index_count = 0 THEN EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX KINE_NAME_PREV_REVISION_UINDEX ON  ' || usr_name || '.' || tbl_name || ' (NAME, PREV_REVISION)';
		END IF;
		END;`,
		`ALTER SESSION SET current_schema = ORACLE`,
	}
)

func New(ctx context.Context, dataSourceName string, tlsInfo tls.Config, connPoolConfig ConnectionPoolConfig, metricsRegisterer prometheus.Registerer) (server.Backend, error) {
	parsedDSN, err := prepareDSN(dataSourceName)

	if err != nil {
		return nil, err
	}
	dialect, err := Open(ctx, "oracle", parsedDSN, connPoolConfig, ":", true, metricsRegisterer)
	if err != nil {
		return nil, err
	}

	dialect.GetSizeSQL = `
	SELECT SUM(bytes)
	FROM dba_segments
	WHERE segment_name = 'KINE';`
	dialect.CompactSQL = `
	DELETE FROM KINE
	WHERE id IN (
    SELECT id
    FROM (
        SELECT prev_revision AS id
        FROM KINE
        WHERE name <> 'compact_rev_key' AND prev_revision <> 0 AND id <= :1
        UNION
        SELECT id
        FROM KINE
        WHERE deleted <> 0 AND id <= :2
    )
);`
	dialect.TranslateErr = func(err error) error {
		if err != nil {
			return server.ErrKeyExists
		}
		return err
	}
	dialect.ErrCode = func(err error) string {
		if err == nil {
			return ""
		}
		if err != nil {
			return err.Error()
		}
		return err.Error()
	}

	if err := setup(dialect.DB); err != nil {
		return nil, err
	}
	dialect.Migrate(context.Background())
	return logstructured.New(sqllog.New(dialect)), nil
}

func setup(db *sql.DB) error {
	logrus.Infof("Configuring database table schema and indexes, this may take a moment...")

	for _, stmt := range schema {
		logrus.Tracef("SETUP EXEC : %v", util.Stripped(stmt))
		_, err := db.Exec(stmt)
		if err != nil {
			return err
		}
	}

	logrus.Infof("Database tables and indexes are up to date")
	return nil
}

func prepareDSN(dataSourceName string) (string, error) {
	if len(dataSourceName) == 0 {
		dataSourceName = defaultDSN
	} else {
		dataSourceName = "oracle://" + dataSourceName
	}

	u, err := url.Parse(dataSourceName)
	if err != nil {
		return "", err
	}

	queryMap, err := url.ParseQuery(u.RawQuery)
	if err != nil {
		return "", err
	}

	// Set up additional parameters for Oracle
	params := url.Values{}
	params.Add("connectTimeout", "5")
	params.Add("poolMinSessions", "1")
	params.Add("poolMaxSessions", "10")
	params.Add("poolIncrement", "1")

	// Append any additional query parameters
	for k, v := range queryMap {
		params.Add(k, v[0])
	}

	u.RawQuery = params.Encode()
	return u.String(), nil
}
